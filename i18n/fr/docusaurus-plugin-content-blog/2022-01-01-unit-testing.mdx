---
slug: unit-testing
title: Les tests unitaires
tags: [test, test unitaire, programmation]
description: L'article du jour est fait en effort conjoint avec mon ancien coll√®gue et mentor <a href="https://www.linkedin.com/in/guillaumefaas/" target="_blank" rel="noreferrer noopener nofollow">Guillaume Faas</a> sous la forme d'une conversation entre 2 d√©veloppeurs. Joins-toi √† moi pour le remercier pour son incroyable implication dans l'√©criture de cet article! Nous esp√©rons tous les 2 que tu vas l'adorer, autant que nous avons ador√© l'√©crire!
image: img/unit-testing.jpg
---

import Figure from '../../../src/components/figure';
import SEO from '../../../src/components/seo';
import Reminder from '../../../src/components/reminder';
import Newsletter from '../../../src/components/newsletter';
import { MAILCHIMP_URL } from '../../../website_config.json';
import { AnchoredH2, AnchoredP } from '../../../src/components/AnchoredHeading';
import randomChoose from '../../../src/utils/randomChoose';

<a href='/blog/unit-testing'>
	<Figure
		data={{
			src: '/img/unit-testing.jpg',
			alt: 'Tests unitaires',
			type: 'image',
		}}
	/>
</a>

L'article du jour est fait en effort conjoint avec mon ancien coll√®gue et mentor <a href="https://www.linkedin.com/in/guillaumefaas/" target="_blank" rel="noreferrer noopener nofollow">Guillaume Faas</a>
(üîπ) sous la forme d'une interview d'un d√©veloppeur.

Joins-toi √† moi pour le remercier pour son incroyable implication dans l'√©criture de cet article! Nous esp√©rons tous les deux que tu vas l'adorer, autant que nous avons ador√© l'√©crire.

<!--truncate-->

<SEO uri='blog/unit-testing' image='img/unit-testing.jpg' type='article' />

---

<Reminder />

---

_tldr; fais des katas en appliquant la m√©thodologie "Test Driven Development" !_

<AnchoredH2 id='presentation'>Pr√©sentation</AnchoredH2>

<AnchoredP>üî∏ Salut Guillaume! Tu sais te pr√©senter s'il te pla√Æt?</AnchoredP>

üîπ Salut Tina√´l! Merci de m'avoir invit√© √† parler sur ton site. Je m'appelle Guillaume Faas et je suis un expert .NET / Software Craftsman, actuellement employ√© chez [Squaremiled S.A.](https://squaremiled.com/).
Je d√©veloppe des logiciels depuis une dizaine d'ann√©es en ayant √©volu√© dans des environnements et secteurs d'activit√©s vari√©s.

<AnchoredH2 id='topic'>Le sujet!</AnchoredH2>

<AnchoredP>üî∏ De quoi va-t-on parler aujourd'hui?</AnchoredP>

üîπ √Ä ton avis? Tu n'as pas lu le titre de l'article on dirait. On va parler de **test unitaire**!

<AnchoredP id='first-encounter'>
	üî∏ Quand est-ce que t'y as touch√© pour la premi√®re fois?
</AnchoredP>

üîπ C'√©tait il y a bien longtemps, dans une galaxie lointaine... J'avais √† peine quelques ann√©es d'exp√©rience √† l'√©poque. J'√©tais dans la m√™me soci√©t√© pendant une majeure partie de ma carri√®re et, par rapport √† mon _day-to-day_, je pensais que j'avais d√©j√† tout vu.
Je commen√ßais √† regarder en ligne √† des _guidelines_, des _best practices_, des _patterns_, etc. Je suis tomb√© sur plein de sujets excitants et surtout nouveaux.
C'√©tait comme si j'avais mis les pieds dans un nouveau monde qui n'avait rien √† voir avec la routine dans laquelle j'√©tais ancr√©. Le _testing_ √©tait √©videmment l'un de ces sujets.
Cependant, j'ai vite r√©alis√© que je devais progresser sur d'autres sujets avant d'√™tre capable d'introduire des tests. Cela m'a pris du temps avant que je ne sois vraiment apte √† travailler avec une approche _test-driven_.

<AnchoredP id='what-is-it'>
	üî∏ Ok! Par contre, histoire de ne pas perdre les lecteurs... tu sais
	expliquer ce qu'est un test unitaire s'il te pla√Æt?
</AnchoredP>

üîπ Oui, bien s√ªr! Un test unitaire, c'est un test qui v√©rifie un _unit of code_. La notion de _unit of code_ varie en fonction des √©coles de testing.
L'√©cole London (ou Mockist) va voir cela comme le plus petit _chunk of code_, on parlera d'une classe ou d'une m√©thode. Par contre, l'√©cole Detroit (ou Classicist) va voir cela comme un _behavior_, donc un ensemble de classes ou de m√©thodes.
Pour les plus curieux, voici un [article](https://medium.com/@adrianbooth/test-driven-development-wars-detroit-vs-london-classicist-vs-mockist-9956c78ae95f) qui d√©taille les diff√©rences entre les deux √©coles.
Je pr√©cise qu'une √©cole n'est pas meilleure que l'autre, chacune a ses avantages et inconv√©nients. C'est une histoire de pr√©f√©rence et de compromis.
La diff√©rence principale tient surtout de la taille de ton _System Under Test_ (SUT) et de la relation entre les diff√©rents collaborateurs.

Mais √† la fin, un test unitaire est simplement **un morceau de code qui valide qu'un autre morceau de code a le r√©sultat et/ou _side effect_ attendu par rapport √† un sc√©nario donn√©**.

<AnchoredP id='hierarchy-position'>
	üî∏ D'accord, mais √ßa se situe o√π dans la "hi√©rachie des tests"?
</AnchoredP>

üîπ Il s'agit de la pyramide de testing (_Agile Testing Pyramid_) mais de gauche √† droite au lieu de bas en haut. Plus tu seras situ√© vers la gauche, plus ton _scope_ est petit et plus tes tests seront nombreux et rapides. La logique inverse est appliqu√©e lorsque tu vas dans l'autre sens.

Nous, on se situe sur la partie "unit" puisque techniquement, il n'y a pas plus petit qu'une _unit_. Un test unitaire doit √™tre ex√©cut√© de fa√ßon _standalone_ dans un environnement _sandbox_.
C'est-√†-dire qu'un test unitaire n'a aucun impact sur l'ext√©rieur du test, et si tu en lances plusieurs en parall√®le, ils ne doivent pas avoir de _side effects_ entre eux.

Cela signifie donc que dans un test unitaire: on ne contacte pas de DB, on √©vite de faire une requ√™te HTTP, d'acc√©der √† un fichier du syst√®me, etc. De la m√™me fa√ßon, on ne va pas contacter les autres d√©pendances de la solution.
On reste vraiment "interne" √† la fonction.

<Figure
	data={{
		src: '/img/software-testing-types.png',
		alt: 'Types de Software Testing',
		type: 'image',
	}}
/>

Voici quelques points de la partie _functional testing_:

-   l'_unit testing_, c'est v√©rifier qu'un composant fonctionne bien. Il s'agit du test le plus rapide, on parlera de _fast feedback loop_ ;
-   l'_integration testing_, c'est v√©rifier que plusieurs composants fonctionnent bien entre eux ;
-   le _user acceptance testing_ qui consiste √† v√©rifier l'enti√®ret√© de l'application tout en √©vitant de contacter les d√©pendances externes (ex: des requ√™tes vers des fournisseurs de donn√©es ext√©rieurs √† ton application).
    Il s'agit du test le plus repr√©sentatif, probablement celui qui a le plus de valeur √† l'√©chelle du produit car il v√©rifie des _business requirements_.

√Ä noter qu'il n'y a pas d'obligation de tous les impl√©menter. On pourrait tr√®s bien avoir une _test suite_ compos√©e uniquement de tests d'une seule de ces cat√©gories. Mais il convient de garder √† l'esprit que notre _test suite_ ne sera pas des plus efficaces.

<AnchoredP>
	üî∏ D'accord! Mais pourquoi le testing, c'est pas r√©alis√© dans le monde
	professionnel?
</AnchoredP>

üîπ En r√©alit√©, une grande partie des d√©veloppeurs n'√©crivent pas ou peu de tests. De plus, les tests d'int√©grations sont moins r√©pandus que les tests unitaires car ils sont plus complexes √† √©crire. Au final, cette t√¢che est souvent vue comme une corv√©e ou alors une _extra step_ que l'on fera uniquement si on a le temps.

<Figure
	data={{
		src: randomChoose(
			'https://miro.medium.com/max/600/1*xHibbXdcePT0GtpeZRgxSA.gif',
			'https://media4.giphy.com/media/hqq505vU9iHCOGySD5/giphy.gif',
			'https://media1.giphy.com/media/VXmWbcDSj2yqnsXUrF/giphy.gif'
		),
		alt: "GIF sur les tests d'int√©gration",
		type: 'image',
	}}
/>

Uncle Bob en a √©galement parl√© √† une conf√©rence √† Londre en 2018:

<Figure
	data={{
		type: 'html',
		width: '560',
		height: '315',
		src: 'https://www.youtube.com/embed/17vTLSkXTOo?start=552&end=720',
		title: 'YouTube video player of SC London Conference 2018',
		allow: 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture',
		allowFullScreen: true,
	}}
/>

<AnchoredP id='objective'>
	üî∏ C'est quoi le but du testing unitaire et quand est-ce que √ßa devrait √™tre
	appliqu√©?
</AnchoredP>

üîπ Le but est assez simple: c'est de montrer qu'une m√©thode fonctionne comme tu l'attends. C'est-√†-dire que tu vas avoir un comportement attendu, par exemple ta m√©thode `getSomething` doit te retourner quelque chose. Tu vas donc tester diff√©rents sc√©narios et v√©rifier qu'elle se comporte toujours de la bonne fa√ßon.

Pour ce qui est du "quand", c'est encore plus simple: √ßa doit √™tre appliqu√© √† partir du moment o√π tu as de la logique quelque part.

<AnchoredP id='pros-and-cons'>
	üî∏ Bah du coup, quels en sont les avantages et inconv√©nients de la mise en
	place de tests unitaires?
</AnchoredP>

üîπ Comme dit pr√©c√©demment, tu √©cris du code qui teste du code. Vu comme cela, on dirait surtout une charge de travail suppl√©mentaire sauf qu'il existe de r√©els int√©r√™ts derri√®re.

1. Le test unitaire sert de **filet de s√©curit√© contre les r√©gressions**.

L'√©tape du refactoring intervient syst√©matiquement dans un projet. Le probl√®me √©tant qu'√† partir du moment o√π l'on modifie quelque chose, il y a un risque de **r√©gression**. On parle de r√©gression lorsque quelque chose fonctionnait auparavant et ne fonctionne plus suite √† un changement.
C'est pr√©cisement ici que le test intervient: il permet de garantir que tes composants fonctionnent toujours comme attendu. Si jamais quelque chose ne fonctionne plus suite √† un changement, la _test suite_ t'affichera les tests qui ont d√©tect√© un probl√®me avec un beau rond rouge. Et √ßa, du point de vue d'un d√©veloppeur, c'est √©norme! Cela veut dire que tu es beaucoup plus serein et que tu passes bien moins de temps √† v√©rifier que tes changements n'ont pas eu d'effets ind√©sirables sur le reste des fonctionnalit√©s.

2. L'√©criture de tests am√©liore la **qualit√© du code** de ton application.

C'est li√© √† ce dont on vient d'aborder. Il est probable que les lecteurs aient d√©j√† rencontr√© une situation similaire: lorsque l'on parle de refactoring √† un _Product Owner_ ou _Product Manager_, la premi√®re crainte est toujours que quelque chose ne fonctionne plus.
Si tu es couvert par une _test suite_, tu n'as pas peur du refactoring. C'est m√™me l'inverse, tu es **encourag√© √† faire du refactoring r√©guli√®rement** tout en √©tant prot√©g√©.

3. Une suite de tests devient ce qu'on appelle une **living documentation**.

Lorsque l'on parle de documentation, on a tous √† l'esprit des commentaires. Le probl√®me est qu'ils ne sont jamais √† jour avec le reste du code. Le code √©volue, la documentation non. Par contre, ton test unitaire sera toujours _up-to-date_. Si ce n'est pas le cas, alors ta suite de tests ne te donnera pas le feu vert pour aller plus loin.

C'est d'autant plus int√©ressant dans le cadre d'une arriv√©e d'un nouveau d√©veloppeur sur le projet. Plut√¥t que de lire tout le code d'une m√©thode pour savoir ce qu'elle fait, il lui suffit de regarder les diff√©rents tests de cette m√©thode. Chaque comportement sera repr√©sent√© par un test avec un _naming_ explicite sur le sc√©nario et r√©sultat attendu (ex: `GetItem_ShouldReturnNotFoundResult_GivenItemIsMissing`). **√áa facilite donc l'_onboarding_!**

4. Cela **r√©duit le temps de d√©tection des bugs**.

On a √©voqu√© le terme _short feedback loop_ un peu plus t√¥t dans la discussion. Les tests unitaires sont tr√®s rapides √† ex√©cuter, ils nous donnent un _feedback_ presque instantan√© sur la sant√© de la solution. Cela veut dire que l'on doit les ex√©cuter r√©guli√®rement. Je sch√©matise mais on a un bouton (ou un raccourci) qui nous donne un statut Vert/Rouge en quelques secondes. Actionner ce bouton doit devenir quelque chose de syst√©matique.
Cela a d√©j√† un int√©r√™t pour nous en tant que d√©veloppeurs mais ce n'est pas tout. On en parlera un peu plus tard!

5. Ce n'est pas un avantage direct mais plut√¥t un effet secondaire: **faire du testing te rend meilleur**.

Pour faire en sorte que tu puisses √©crire des tests apportant une r√©elle valeur, tu dois respecter certains principes. Tu dois toujours avoir une certaine couche d'abstraction pour _mocker_ tes d√©pendances, tu dois pouvoir les injecter, tu dois limiter les responsabilit√©s de tes composants, etc... en fait tu vas te forcer √† appliquer plusieurs principes r√©guli√®rement (SOLID par exemple).
Du coup, cela te force √† casser tes composants, √† les d√©coupler, √† penser √† leurs interations et responsabilit√©s. Bref, √† r√©fl√©chir et √† te poser beaucoup de questions. Mine de rien, on parle de _code design_! Et donc, action-r√©action: tu deviens meilleur au fil du temps. Cela fait tr√®s _Happy End_ mais tu vois o√π je veux en venir.

üî∏ Et comme c'est peu mis en place dans les entreprises, c'est vu comme "nouveau" et √ßa motive √† en apprendre plus!

üîπ Je te rejoins sur l'aspect nouveaut√© mais il reste surtout pr√©sent au d√©but lorsqu'on d√©couvre le sujet. Mais il y a une partie d'interpr√©tation dans tout cela: certains (comme toi) le voient comme quelque chose d'int√©ressant, d'autres le voient comme une corv√©e ou une pression suppl√©mentaire. Tu trouveras toujours des personnes r√©fractaires aux tests pour des raisons diverses et vari√©es. Peut-√™tre qu'on aura l'occasion d'aborder les raisons qui sont g√©n√©ralement √©voqu√©es.

Pour revenir √† ta question, voici les inconv√©nients qui me viennent √† l'esprit:

1. On l'a mentionn√©, il y a des pr√©-requis: il faut comprendre les piliers de l'orient√© objet, l'injection de d√©pendances, les principes [SOLID](https://www.digitalocean.com/community/conceptual_articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design), etc.
2. Le fait que l'on trouve peu de projets avec de r√©elles _test suites_ rend l'apprentissage moins accessible. Il en va de m√™me pour trouver un coach passionn√© par ce sujet.
3. Il y a une courbe d'apprentissage/de progression assez importante. Tout le monde passe par une phase de frustration au d√©but parce que l'on est pas √† l'aise et on a l'impression d'√™tre plus lent. Il faut r√©sister et pers√©v√©rer car les tests nous feront en r√©alit√© aller plus vite. On en parlera avec l'approche TDD.
4. Cela demande de la pr√©paration : il faut r√©fl√©chir √† l'architecture du projet, aux relations entre les diff√©rents composants, etc... Vu comme cela, ce n'est pas vraiment un inconv√©nient mais on ne peut pas (plus?) se lancer t√™te baiss√©e dans un d√©veloppement sans un minimum de r√©flexion.
5. Il y a un manque de compr√©hension du c√¥t√© des autres √©quipes intervenant sur le d√©veloppement du produit, notamment non-IT. On retombe toujours sur des discussions sur le _Return On Investement_ (ROI) ou l'impact sur la v√©locit√©.

On entend souvent dire que "cela prend du temps et que cela sera planifi√© plus tard" ou que "les d√©veloppeurs n'ont pas le temps" mais ces arguments ne sont pas vraiment valables.
En effet, le premier indique clairement un manque de vision et de compr√©hension du testing. D√©j√† parce que "plus tard" n'arrive jamais. Mais surtout, faire les tests √† la fin du d√©veloppement n'a aucun sens. On perd tous les avantages qu'apporte le testing. Je l'ai d√©j√† dit mais on en parlera avec l'approche TDD.
Ensuite, le second indique un probl√®me d'organisation. Les tests devraient √™tre inclus dans les estimations et pas comme un travail suppl√©mentaire √† r√©aliser.

<AnchoredP id='test-coverage'>
	üî∏ Et le <span style={{ fontStyle: 'italic' }}>test coverage</span>, dans
	tout √ßa?
</AnchoredP>

üîπ Tester, c'est super et on ressent les b√©n√©fices. Cependant, il faut aussi faire un statut sur l'√©tat de la _test suite_. C'est l√† qu'on arrive sur le _code coverage_. C'est une m√©trique informative sur la progression de couverture de tests de ton application.
J'insiste vraiment sur le c√¥t√© **informatif**. Ce serait une erreur de mesurer la qualit√© de la suite de tests sur base de sa couverture. C'est une m√©trique de quantit√© et non de qualit√©.
J'ai d√©j√† lu des articles sur des soci√©t√©s qui ont int√©gr√© la valeur de _code coverage_ dans les objectifs des d√©veloppeurs et cela a incit√© les d√©veloppeurs √† utiliser de faux tests pour faire gonfler le coverage.

Le seul moyen de v√©rifier la qualit√© d'une _test suite_ d'un projet, c'est de se poser quelques questions:

-   Est-ce que le temps de d√©veloppement g√©n√©ral des fonctionnalit√©s reste approximativement le m√™me avec le temps?
-   Est-ce que la quantit√© de bugs trouv√©s en production diminue avec le temps?
-   Est-ce que tu arrives √† facilement accueillir une nouvelle ressource au sein de l'√©quipe de d√©veloppement?
-   Est-ce que les d√©veloppeurs ont confiance en leur _test suite_? Est-ce qu'elle est repr√©sentative de l'√©tat de sant√© de la solution? Est-ce qu'un rond vert garantit vraiment qu'un composant fonctionne?

Si tu es en mesure de r√©pondre "oui" √† toutes ces questions, f√©licitations! Tu peux √™tre fier de la _test suite_ que tu as mis en place.
Le souci? C'est difficile d'avoir une r√©ponse √† ces questions alors que tu dois rendre des comptes _day one_... Tu remarques d'ailleurs que les trois premi√®res font r√©f√©rence au **temps**.

<AnchoredP id='cost'>
	üî∏ Bon sinon... question co√ªt, qu'est-ce qu'il en est? Parce que finalement,
	√©crire un test unitaire, c'est tout de m√™me √©crire du code. √áa co√ªte!
</AnchoredP>

üîπ Je vois l√† o√π tu veux en venir. Non, cela ne co√ªte pas plus sauf si tu factures au caract√®re!
M√™me si tu √©cris plus de code, tu es vraiment gagnant et pas que sur l'aspect temps. Je t'ai dit qu'on devait parler de TDD? Parce que cela te fait m√™me gagner du temps √† court-terme. Bref.
D√©velopper une fonctionnalit√© peut te prendre un peu plus de temps en sachant que cela d√©pendra surtout de ton aisance avec l'√©criture de tests. D'un autre c√¥t√©, cela va surtout te "sauver la vie" pas mal de fois parce que tu vas √©viter √©normement de bugs qui, en temps normal,
seraient arriv√©s bien plus tard dans ton _process_, lors des tests utilisateur sur un environnement de QA ou en production.
Toi qui voulais parler d'argent, **plus un bug est d√©couvert tard, plus il co√ªte cher**:

<Figure
	data={{
		src: 'https://assets.deepsource.io/995f56d/images/blog/cost-of-fixing-bugs/chart.jpg',
		alt: 'Co√ªt de correction des bugs',
		type: 'image',
		url: 'https://deepsource.io/blog/exponential-cost-of-fixing-bugs/',
	}}>
	Le co√ªt de correction d'un bug sur base du moment o√π il a √©t√© d√©tect√©,
	sourc√© chez{' '}
	<a href='https://deepsource.io/blog/exponential-cost-of-fixing-bugs/'>
		DeepSource
	</a>
	!
</Figure>

Et c'est tout √† fait normal.

On peut reparler de la _fast feedback loop_: si un bug est d√©couvert par un test unitaire, c'est en local sur ta machine, juste apr√®s le changement (n'oublie pas de _rebuild_ et de _rerun_ ta suite de tests). Il est identifi√© rapidement et corrig√© rapidement.
√Ä contrario, un bug qui passe en production... il est d√©couvert par un utilisateur qui remonte le probl√®me √† ta _product team_ qui elle doit analyser le _feedback_ et ouvrir un ticket dans ton _backlog_. Ce ticket, il va √™tre prioris√© par ton _Product Owner_ pour √™tre inclus dans la prochaine it√©ration puis il sera assign√© √† un d√©veloppeur. En admettant que ce ne soit pas toi, il y aura une phase d'investigation (reproduction du bug), une phase de correction de bug et apr√®s il doit repartir sur tous les environnements et √™tre valid√© par des _Quality Assurance Users_.

J'ai volontairement pris un cas extr√™me pour montrer le pire sc√©nario mais c'est aussi la fa√ßon d'√™tre le plus explicite sur le probl√®me.
Ce qu'il est important de retenir, c'est qu'un test peut faire gagner beaucoup de temps √† beaucoup de personnes, aussi simple soit-il.

_ndlr: pour en savoir plus sur les raisons qui font qu'un logiciel a des bugs, n'h√©sitez pas √† consulter [cette page](https://www.softwaretestinghelp.com/why-does-software-have-bugs) et [d'autres sur le web](https://www.google.com/search?q=why+do+softwares+have+bugs)!_

<AnchoredH2 id='details'>En d√©tails</AnchoredH2>

<AnchoredP id='black-and-white-boxes'>
	üî∏ Ok! Et si on parlait maintenant de{' '}
	<span style={{ fontStyle: 'italic' }}>black box</span> et{' '}
	<span style={{ fontStyle: 'italic' }}>white box testing</span>?
</AnchoredP>

üîπ J'aime les sch√©mas, tu aimes les sch√©mas? C'est bien les sch√©mas!

<Figure
	data={{
		src: '/img/black-white-box-testing.png',
		alt: 'Black and white box testing',
		type: 'image',
		style: { border: '.5em solid black' },
	}}>
	Les diff√©rences entre <span style={{ fontStyle: 'italic' }}>black box</span>{' '}
	et <span style={{ fontStyle: 'italic' }}>white box testing</span>
</Figure>

Le **black box testing**, c'est donner une information d'entr√©e au SUT et v√©rifier l'information de sortie. C'est aussi simple que √ßa: on ne prend pas en compte ce qu'il se passe √† l'int√©rieur de la m√©thode.
Il y a un cas pr√©cis o√π ce type de testing sera obligatoire: les m√©thodes pures. Ces m√©thodes n'ayant aucune d√©pendance ou variables partag√©es, elles n'ont donc aucun _side effect_. Le **black box testing** est donc une √©vidence mais cela rend aussi le test extr√™mement robuste car rien ne vient impacter le r√©sultat du test.

Prenons par exemple une m√©thode `Sum` d'une classe `Calculator`. On est exactement sur le sc√©nario mentionn√© plus haut:

```csharp title='tests/CalculatorTests.cs'
[TestClass]
public class CalculatorTests
{
	[TestMethod]
	public int Sum_Should_ReturnTheSumOfTheTwoNumbers()
	{
		Calculator calculator = new();

		int result = calculator.Sum(2,3);

		Assert.AreEqual(expected: 5, actual: result);
	}
}
```

On ne conna√Æt pas l'impl√©mentation de la m√©thode, mais on a √©crit un test. On lui donne des valeurs en entr√©e, et on v√©rifie la valeur de sortie.
Pour le reste des sc√©narios, je trouve dommage de s'arr√™ter l√†. C'est une pr√©f√©rence personnelle, je trouve le **white box testing** plus pertinent en tant que _Mockist_.

De l'autre c√¥t√©, on a donc ce **white box testing**. √Ä premi√®re vue, c'est la m√™me chose: on donne un _input_ et on v√©rifie l'_output_. Mais on va aussi v√©rifier ce qu'il se passe √† l'int√©rieur du SUT.
On peut donc v√©rifier que le SUT a bien fait appel √† sa d√©pendance, que la valeur a bien √©t√© mise dans un cache, sauvegard√©e dans un repo, qu'un event a bien √©t√© √©mis, etc.
Cela nous permet de v√©rifier chaque _behavior_ avec ses _side effects_.

<AnchoredP id='how-to-write'>
	üî∏ La question que tous se posent... Comment √©crire de bons tests unitaires?
</AnchoredP>

üîπ Je ne pense pas qu'il y ait de bons ou de mauvais tests unitaires... Evidemment que si!
Il faut r√©fl√©chir avant sur ce que tu veux faire. √áa peut para√Ætre b√™te dit comme √ßa mais _think before you do_. C'est que j'expliquais lorsque je parlais du fait que faire des tests te rend meilleur.
Si tu veux faire des tests efficaces, il faut r√©fl√©chir sur la fa√ßon dont tes composants vont communiquer entre eux. En fait, tes tests seront efficaces √† partir du moment o√π ils seront faciles √† faire. Et si tu te rends compte qu'ils ne le sont pas, c'est qu'il y a un soucis dans ton code.

Exemple: j'ai un _service_ qui doit cr√©er un utilisateur. **Avant d'√©crire mon test**, je dois me poser quelques questions: quelles sont les responsabilit√©s de mon service?
Est-il responsable d'envoyer une requ√™te HTTP √† un fournisseur externe pour r√©cup√©rer des informations? Est-il responsable de la persistence en base de donn√©es? Est-il responsable du _logging_?
_Divide &amp; Conquer_: une d√©pendance ici, une l√†, et une autre l√†... Au final, que reste-t-il dans mon service? L'orchestration d'un processus d√©l√©gu√© √† diff√©rentes d√©pendances (ex: client http, repository, logger, etc) et √©ventuellement une modification de l'√©tat d'une entit√©. C'est tout.

Au final, un "bon" test doit:

-   te prot√©ger contre les r√©gressions ;
-   √™tre r√©sistant au refactoring ;
-   te donner un feedback rapide ;
-   √™tre maintenable.

<AnchoredP id='tips-to-start'>
	üî∏ Et, sinon... T'as des conseils pour se lancer dans le testing unitaire?
</AnchoredP>

üîπ Je recommande aux personnes qui veulent d√©marrer le testing de commencer directement avec le _Test Driven Development_.
Si le test est √©crit apr√®s l'impl√©mentation, c'est pas vraiment objectif car tu connais d√©j√† l'impl√©mentation donc ton test est fortement li√© √† ton impl√©mentation. De plus, le code fonctionne d√©j√† donc le test sera per√ßu comme une perte de temps. Mais surtout: on a b√©n√©fici√© d'aucun avantage du testing lors de la phase d'impl√©mentation.

Pour cela, vous n'√™tes pas seul. Il existe des tonnes de resources disponibles pour vous aider.
Voici plusieurs livres que j'aurais aim√© avoir lus au d√©but de ma carri√®re:

-   "Test Driven Development - By Example" par Kent Beck.
-   "Unit Testing - Principles, Practices and Patterns" par Vladimir Khorikov.

√âgalement, voici un site rempli de conseils et astuces sur TDD avec un grand nombre de katas pour progresser: [TDD Buddy](http://www.tddbuddy.com/).

En parlant de katas, faites des katas. Faites pleins de katas et faites en √† plusieurs (_pair_ et/ou _mob programming_) si vous en avez la possibilit√©. C'est fun et c'est tr√®s formatteur, notamment sur le fait de d√©marrer avec des exercices simples et progressivement augmenter la difficult√© jusqu'√† se retrouver avec des situations similaires √† ce que l'on peut trouver dans des projets r√©els. En plus de [TDD Buddy](http://www.tddbuddy.com/), je pourrais recommander [Code Wars](https://www.codewars.com/) si vous √™tes en manque d'inspiration.
Sans forc√©ment faire de l'auto-promotion, vous pouvez aussi trouver quelques katas sur mon [GitHub](https://github.com/Tr00d/).

Un dernier conseil pour d√©marrer le testing, on peut se r√©f√©rer √† ce qu'on appelle le triple A (AAA), qui signifie _Arrange, Act, Assert_, pour rendre les tests plus clairs et organis√©s. Le but est de diviser son test unitaire en 3 parties distinctes:

1. _arrange_ : c'est le sc√©nario, la partie o√π tu pr√©pares les donn√©es _input_ de ta m√©thode ;
2. _act_ : c'est l'action, le fait de r√©aliser l'appel √† la m√©thode que tu vas tester ;
3. _assert_ : c'est la v√©rification du _behavior_, l√† partie o√π tu v√©rifies l'_output_ ou les _side effects_.

<AnchoredP id='bad-smells'>
	üî∏ Quels sont les "bad smells" dans l'unit testing?
</AnchoredP>

üîπ J'en vois quelques-uns...

-   une partie _arrange_ qui fait 15 lignes... C'est trop compliqu√©. On voit clairement que la m√©thode test√©e fait trop de choses car le sc√©nario est trop compliqu√© √† mettre en place!
-   On dit qu'**un test ne doit avoir qu'une et une seule raison d'√©chouer**. Un test ne devrait contenir qu'un seul _assert_.
-   Le fait que tu aies du mal √† √©crire des tests unitaires, non pas √† cause du fait que tu n'aies pas la connaissance n√©cessaire mais plut√¥t en rapport au code √† tester... c'est qu'il y a un soucis au niveau de ton composant. Alors, prends du recul et penses aux responsabilit√©s.

<AnchoredH2 id='more-stuff'>Pour aller plus loin</AnchoredH2>

<AnchoredP id='libraries'>
	üî∏ Tu as des librairies int√©ressantes en t√™te pour faciliter le travail?
</AnchoredP>

üîπ Oui. Pour moi, on peut consid√©rer trois groupes de librairies:

1. les librairies de testing qui permettent de g√©n√©rer des tests ;
2. les librairies de mocking qui permettent de surcharger le comportement de tes d√©pendances et de les monitorer ;
3. les librairies de g√©n√©ration de donn√©es.

Pour ma part:

|                     **Frameworks de test**                     |                **Librairies de mocking**                 |          **Librairies de g√©n√©ration de donn√©es**           |
| :------------------------------------------------------------: | :------------------------------------------------------: | :--------------------------------------------------------: |
| [MSTest](https://www.nuget.org/packages/MSTest.TestFramework/) |        [Moq](https://www.nuget.org/packages/Moq/)        | [AutoFixture](https://www.nuget.org/packages/AutoFixture/) |
|         [NUnit](https://www.nuget.org/packages/NUnit/)         |    [NInject](https://www.nuget.org/packages/Ninject/)    |
|         [XUnit](https://www.nuget.org/packages/xunit/)         | [WireMock](https://www.nuget.org/packages/WireMock.Net/) |

üî∏ Sur ce point-ci particuli√®rement, j'aimerais mettre en avant le fait qu'il existe aussi des librairies de test pour le _front-end_. En fait, le testing unitaire n'est pas r√©serv√© aux d√©veloppeurs
_back-end_. On citera notamment [Jest](https://www.npmjs.com/package/jest), [Mocha](https://www.npmjs.com/package/mocha), [Cypress](https://www.npmjs.com/package/cypress) et [Jasmine](https://www.npmjs.com/package/jasmine) comme librairies fortement li√©es au testing dans des applications JavaScript.

<AnchoredP id='what-is-tdd'>
	Du coup, tu n'arr√™tes pas d'en parler. C'est quoi le{' '}
	<span style={{ fontStyle: 'italic' }}>Test Driven Development</span> (TDD)?
</AnchoredP>

üîπ Je suis content que tu poses enfin la question! C'est pas comme si je t'avais tendu la perche plus d'une fois... C'est la joie, le bonheur, la r√©ponse ultime au sens de la vie, c'est tout √ßa!
Non, je rigole. En fait, c'est une fa√ßon de mettre les tests au centre de ce que tu fais. On a parl√© de tous les points positifs de faire des tests unitaires et aussi du fait qu'on les perdait si on faisait les tests √† la fin sans forc√©ment aller dans le d√©tail.
En fait, la meilleure fa√ßon de b√©n√©ficier des avantages des tests, c'est de les faire en premier mais ce n'est pas que √ßa. Ce n'est pas d'abord faire tous les tests puis ensuite faire l'impl√©mentation.
Non, il y vraiment un aspect it√©ratif que l'on retrouve d'ailleurs dans l'Agilit√©. Tu y vas √©tape par √©tape (_baby steps_), tu ajoutes de nouveaux _behaviors_ en garantissant que ceux pr√©c√©demment ajout√©s fonctionnent toujours. Le filet de s√©curit√© s'agrandit petit √† petit naturellement.
On peut pr√©senter cela diff√©remment: imaginons une √©chelle. Cela sera toujours plus facile de la monter marche par marche que de les monter trois par trois.

J'ajouterais que contrairement aux id√©es re√ßues, TDD ne rend pas la dur√©e de d√©veloppement plus longue, bien au contraire. Par exemple, il n'est pas n√©cessaire d'ex√©cuter la solution pour savoir que le code fonctionne car il a enti√®rement √©t√© d√©velopp√© sur base de tests.

<Figure
	data={{
		src: '/img/test-driven-development.png',
		alt: 'Cycle du TDD',
		type: 'image',
		style: { border: '.5em solid black' },
	}}>
	Le cycle de d√©veloppement sous TDD
</Figure>

La premi√®re √©tape, c'est l'√©criture d'**un** test unitaire. Normalement, ce test doit _obligatoirement_ √©chouer puisqu'aucune impl√©mentation n'a √©t√© √©crite pour qu'il r√©ussise.
L'√©tape suivante, c'est donc d'√©crire le code qui permet de faire passer le test au vert. Et l√†, c'est tr√®s important de savoir que ce passage de rouge vers le vert doit √™tre **le plus court possible**. C'est le moment o√π on √† le droit d'√©crire du code "moche", d'_hardcoder_ un r√©sultat, de dupliquer, de coller une r√©ponse de StackOverflow, etc. Cela peut para√Ætre bizarre au d√©but mais il y a un vrai int√©r√™t: v√©rifier que l'ajout d'un nouveau _behavior_ est possible sans casser tout ce qui a √©t√© fait auparavant.
L'√©tape suivante, c'est le refactoring. On a fait un code horrible, il faut maintenant faire quelque chose de propre. J'ai parl√© plus t√¥t de refactoring plus simple et s√©curis√©: on y est! On a notre _green light_ et le _behavior_ est garanti tant que cette _light_ reste _green_. On a notre _fast feedback loop_ √† port√©e de main (ou de clic, ou de raccourci) pour savoir si tout est ok. Tu me suis?
Ensuite, on atteint la fin du cycle. Cela veut dire une chose: on recommence.

üî∏ Je vais fournir un petit exemple pour que tout le monde se situe! Je vais faire √ßa avec un calculateur de longueur de cha√Æne de caract√®res tiens, c'est simple √† r√©aliser.
Donc, je commence par √©crire le test unitaire:

```csharp title='tests/StringCalculatorTests.cs'
[TestClass]
public class StringCalculatorTests
{
	[TestMethod]
	public int Length_ShouldReturn_CorrectLength()
	{
		StringCalculator calculator = new();

		int result = calculator.Length("string"); // "string" fait 6 caract√®res de long, non?

		Assert.AreEqual(expected: 6, actual: result);
	}
}
```

Le test √©choue parce que je n'ai pas encore cr√©√© la classe `StringCalculator`. Prochaine √©tape!

```csharp title='src/StringCalculator.cs'
public class StringCalculator
{
	public int Length (string str)
	{
		return 6;
	}
}
```

Ici, nous sommes donc √† l'√©tape verte. On doit donc passer √† l'√©tape bleue.

üîπ J'ajouterais que ton code est super moche vu que tu as _hardcod√©_ la valeur. Mais c'est bien! C'est le but!

üî∏ La plus longue: r√©aliser un refactoring du code qui nous permet de r√©pondre au besoin demand√© (calculer la longueur d'une cha√Æne de caract√®res) tout en ne cassant pas le test:

```csharp title='src/StringCalculator.cs'
public class StringCalculator
{
	public int Length (string str)
	{
		return str.Length; // la mani√®re la plus propre de renvoyer la longueur d'une cha√Æne de caract√®res en C#
	}
}
```

Et voil√†! Nous pouvons commencer l'√©criture d'un nouveau test unitaire.

üîπ C'est un exemple assez simple mais tu y es. Il faut bien noter qu'il y a tout de m√™me des r√®gles √† respecter avec TDD mais je pourrais en parler pendant des heures alors on va s'arr√™ter ici!

<AnchoredP id='what-is-tcr'>
	üî∏ D'accord! D'ailleurs, j'ai ou√Øe dire que t'as r√©cemment appris le{' '}
	<span style={{ fontStyle: 'italic' }}>
		Test &amp;&amp; Commit || Revert
	</span>{' '}
	(TCR). Tu sais expliquer en quoi √ßa consiste?
</AnchoredP>

üîπ Exact, j'ai eu la chance de prendre connaissance de cette pratique via un _workshop_. Pour sch√©matiser, disons que c'est une vision extr√™me de TDD. Le meilleur moyen de l'utiliser est avec un script s√©par√©.
Ce script va analyser ta solution √† chaque sauvegarde et va ensuite ex√©cuter tous tes tests. Si tous tes tests sont vert, il cr√©e un commit qui repr√©sente un √©tat stable de ta branche (Test &amp;&amp; Commit).
Si tu as un seul test qui ne passe plus, il fait un rollback pour revenir √† l'√©tat du dernier commit (Revert), qui lui est stable.
Cela te force √† avancer en _baby steps_ et une chose est mise en √©vidence: c'est ton dernier changement qui a cass√© quelque chose.

Au d√©but, tu passes par une phase de frustration parce que tu peux perdre du code mais justement, cela t'incite √† avancer petit √† petit pour limiter tes pertes. Plus tes _steps_ sont petites, moins tu risques de perdre du code. C'est un super enseignement en compl√©ment de TDD.
Losque tu deviens relativement √† l'aise avec tout √ßa, tu remarques que tu avances de plus en plus vite et surtout, tu as toujours une branche qui fonctionne.

<AnchoredH2 id='conclusion'>Conclusion</AnchoredH2>

<AnchoredP>üî∏ Un dernier mot pour cl√¥turer cette interview?</AnchoredP>

üîπ "Victoriae mundis et mundis lacrima", ca ne veut absolument rien dire mais je trouve que c'est assez dans le ton.
Plus s√©rieusement, √ßa fait d√©j√† un moment qu'on discute mais on a seulement gratt√© la surface. Il reste beaucoup de points √† aborder sur le testing. Je conseillerais donc vivement aux lecteurs d'√™tre curieux sur le sujet, de lire et surtout de pratiquer. N'h√©sitez pas √† demander de l'aide autour de vous.
Et sinon, le testing, √ßa vous tente?

<Figure
	data={{
		src: '/img/developers-deliver-working-solutions.jpg',
		alt: 'Developers deliver working solutions, not testable code',
		type: 'image',
		style: { width: '50%', border: '.1em grey solid' },
	}}
/>

<Newsletter url={MAILCHIMP_URL} />

export const toc = [
	{ value: 'Pr√©sentation', id: 'presentation', level: 2 },
	{ value: 'Le sujet', id: 'topic', level: 2 },
		{ value: 'Premi√®re rencontre', id: 'first-encounter', level: 3 },
		{ value: "Qu'est-ce que c'est", id: 'what-is-it', level: 3 },
		{ value: 'O√π √ßa se situe dans la "hi√©rarchie des tests"', id: 'hierarchy-position', level: 3 },
		{ value: 'But du testing unitaire', id: 'objective', level: 3 },
		{ value: 'Avantages et inconv√©nients', id: 'pros-and-cons', level: 3 },
		{ value: 'Test Coverage', id: 'test-coverage', level: 3 },
		{ value: 'Le co√ªt', id: 'cost', level: 3 },
	{ value: 'Plus en d√©tails', id: 'details', level: 2 },
		{ value: 'Black box &amp; white box, k√©sako', id: 'black-and-white-boxes', level: 3 },
		{ value: 'Comment en √©crire efficacement', id: 'how-to-write', level: 3 },
		{ value: 'Tips pour se lancer', id: 'tips-to-start', level: 3 },
		{ value: 'Les "Bad Smells"', id: 'bad-smells', level: 3 },
	{ value: 'Pour aller plus loin', id: 'more-stuff', level: 2 },
		{ value: "Librairies facilitant l'impl√©mentation", id: 'libraries', level: 3 },
		{ value: 'Le Test Driven Development', id: 'what-is-tdd', level: 3 },
		{ value: 'Le Test &amp;&amp; Commit || Revert ', id: 'what-is-tcr', level: 3 }
	{ value: 'Conclusion', id: 'conclusion', level: 2 }
];
